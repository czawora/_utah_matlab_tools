function nsx2mda(varargin)

    % parse inputs and validate

    fprintf('****************************************************\n');
    fprintf('* %s\n', mfilename);

    p = inputParser;
    p.addParameter('nsx_fpath', '', @ischar);
    p.addParameter('jacksheet_fpath', '', @ischar);
    p.addParameter('refset', '', @ischar);
    p.addParameter('session_dir', '', @ischar);
    p.addParameter('min_range_cutoff_microvolt', '10', @ischar);
    p.addParameter('min_duration_data_min', '5', @ischar);
    
    p.addParameter('ignoreShortFile', '1', @ischar);
    
    parse(p, varargin{:});
    
    disp(p.Results);
    
    nsx_fpath = p.Results.nsx_fpath;  
    jacksheet_fpath = p.Results.jacksheet_fpath;
    refset = p.Results.refset;
    session_dir = p.Results.session_dir;
    min_range_cutoff_ungained = eval(p.Results.min_range_cutoff_ungained);
    min_duration_data_min = eval(p.Results.min_duration_data_min);
    
    if isequal(refset, '') 
        error('refset must be an string integer matching a microDevNum in the jacksheet');
    else
        refset = eval(refset);
    end
    
    ignoreShortFile = logical(str2num(p.Results.ignoreShortFile));
    
    if ~exist(nsx_fpath, 'file')
       fprintf('%s is not a valid file\n', nsx_fpath); 
    end
    
    if ~exist(jacksheet_fpath, 'file')
       fprintf('%s is not a valid file\n', jacksheet_fpath); 
    end
    
    if ~exist(session_dir, 'dir')
       fprintf('%s is not a valid dir\n', session_dir); 
    end
     
    ignore_me_fname = [session_dir sprintf('/_ignore_me%d.txt', refset)];

    %convert min_range_cutoff_microvolt to millivolt
    min_range_cutoff_millivolt = min_range_cutoff_ungained * 0.25 * (1/1000); 
    
    % read the jacksheet    
    jacksheet = readtable(jacksheet_fpath);
    
    % jacksheet for this refset
    used_jacksheet = jacksheet( jacksheet{:,'MicroDevNum'} == refset && jacksheet{:,'RangeMilliV'} > min_range_cutoff_millivolt , : );
    
    % check if all the channels failed to pass the range filter
    if isempty(used_jacksheet)
       
        ignore_me_fid = fopen(ignore_me_fname, 'w');
        fprintf(ignore_me_fid, 'all channels have data range < %0.4f milliV', min_range_cutoff_millivolt);
        fclose(ignore_me_fid);
    end
    
    % check if the file is too short to care about
    if ignoreShortFile
        
        if used_jacksheet{1, 'DurationMin'} < min_duration_data_min
            
            ignore_me_fid = fopen(ignore_me_fname, 'w');
            fprintf(ignore_me_fid, 'data length less than 5 min ( %0.2f )', nsx.MetaTags.DataDurationSec/60);
            fclose(ignore_me_fid);
        end
        
    end
        

    % read the data
    nsx = concatOpenNSx(nsx_fpath);
    
    % save this for use in the final step of the pipeline
    nsx_postProc = nsx.postProc;
    save([session_dir '/nsx_postProc.mat'], 'nsx_postProc');

    
    % fiddle with electrodeLabels
    electrodeLabels = { nsx.ElectrodesInfo.Label };
        
    % remove null spaces from electrodeLabels
    for iElec = 1:length(electrodeLabels)

        currentElec = electrodeLabels{iElec};
        endIdx = 1;

        while (endIdx + 1) <= length(currentElec) && double(currentElec(endIdx + 1)) ~= 0
            endIdx = endIdx + 1;     
        end
        
        electrodeLabels{iElec} = electrodeLabels{iElec}(1:endIdx);
    end
    
    % which electrodeLabels are in the refset
    refset_nsx_chan_filt = cellfun( @(x) any(cellfun( @(y) isequal(x, y) , refset_jacksheet{:, 'ChanName'})), electrodeLabels);
   
    
    % if no channel pass, write and _ignore_me, else write the data out, reference set
    if isempty(nsx_channelNames_match)
       
        ignore_me_fid = fopen(ignore_me_fname, 'w');
        fprintf(ignore_me_fid, 'all channels unselected or have data range < 10');
        fclose(ignore_me_fid);
    else
        
        for iRef = 1:size(elInfo, 1)

            output_chans_tmp_fname = [output_dir '/' input_fname_no_path_no_ext sprintf('_refset%d_used_chans.tmp%d', iRef, refset)];
            output_chans_txt_fname = [output_dir '/' input_fname_no_path_no_ext sprintf('_refset%d_used_chans.txt', iRef)];
            
            %find names in nsx_channelNames_match that are in chan_names_by_refset{iRef}
            current_refset_chan_names = chan_names_by_refset{iRef};
            current_refset_idx = [];

            output_chans_tmp_fid = fopen(output_chans_tmp_fname, 'w');        

            for iRefChan = 1:length(current_refset_chan_names)

                current_refset_chan = current_refset_chan_names{iRefChan};
                current_refset_chan_binar = cellfun(@(x) isequal(x, current_refset_chan), nsx_channelNames_match);

                if any(current_refset_chan_binar)

                    fprintf(output_chans_tmp_fid, sprintf('%s\n', current_refset_chan));
                    current_refset_idx(length(current_refset_idx) + 1) = find(current_refset_chan_binar);
                end

            end

            fclose(output_chans_tmp_fid);
            movefile(output_chans_tmp_fname, output_chans_txt_fname);
            

            if iRef == refset
            
                output_mda_fname = [output_dir '/' input_fname_no_path_no_ext sprintf('.refset%d.mda', iRef)];

                writemda(nsx.Data(current_refset_idx, :), output_mda_fname, 'int16');
                
                %calcWindowStats(nsx.Data(current_refset_idx, :), nsx.MetaTags.SamplingFreq, [output_dir '/raw_'  sprintf('quantiles.refset%d.mat', iRef)], current_refset_chan_names);
                
                sampling_freq = nsx.MetaTags.SamplingFreq;
                save([output_dir '/samplingFreq.mat'], 'sampling_freq');
            
            end  
            
        end
    end
    
   
end